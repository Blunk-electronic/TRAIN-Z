;V73
;alle Enable und Disable SIO A Aufrufe kommentiert
;position der sys variablen neu geordnet
;help befehl eingebaut
;V74
;RAM groesse wird bei mismatch bei ram size check erkannt und in RAM_TOP geschrieben
;cm befehl entfernt
;rs befehl kann zum loeschen des rams genutzt werden
;V75
;pout und pin eingebaut
;pao, pbo, pbi, pai entfernt
;ws warmstart befehl eingebaut
;mr master reset befehl eingebaut
;V76
;call STR_TERM eingebaut, wo vom host eingabe erwartet wird
;vm verursacht warscheinlich im host einen buffer overrun
;nach cmd wird STR_TERM gesendet. sinnvoll ?
;befehle und textausgaben gekuerzt
;V77
;herzschlag eingebaut
;CTC init optimiert
;V78
;PIO init optimiert
;APP_ACCU und APP_CHAR eingebaut
;vm verbessert (liest 16 x 16 Adressen aus)
;V781
;APP_ACCU statt TX_A im gesamten programm
;TX_A entfernt
;TX_STD_OUT eingebaut (fuert selbststaending call TX_STR_TERM aus)
;TX_HL entfernt
;alte auskommentierte zeilen entfernt
;wait_0 entfernt
;V783
;req_number eingebaut (soll req_byte und req_word ersetzen)
;dld funktioniert nicht !
;V784
;dld repariert, EI am Ende von CT3_ZERO eingefuegt
;V79
;alle req_word und req_byte gegen req_number ersetzt
;alle call set_cmd_incpl am anfang von cmd ausfuehrung kommentiert
;statt dessen wird call set_CMD_incpl an anfang von req_number ausgefuehrt
;in vm und mm nach req_number wird new_line gesendet
;V791
;req_number erweitert: bei fehlerhafter eingabe wird zusaetzlich nach "..?" der stack
;manipuliert und nach EO_post_proc gesprungen.
;dies kann die i2c funktionen beeintraechtigen, denn diese werden in diesem fall abgebrochen
;und der i2c-Bus und dessen teilnehmer nicht rueckgesetzt !
;alte kommentierte zeilen entfernt
;V792
;fehlermeldung "ackn error" durch "..?" ersetzt
;label "ackn_err" umbenannt nach "error"
;V80
;NEW_LINE wird als echo auf cr immer gesendet (eingebaut in RX_CHA_AVAILABLE)
;alle TX NEW_LINE nach req_number kommentiert
;V801
;RX_CHA_AVAILABLE ueberarbeitet und echo-off funktion eingebaut
;alte kommentierte programmzeilen entfernt
;NMI wird ausgewertet
;V802
;in req_number wird jedes konvertierte byte in den lang-zahlen-speicher gelegt
;das hoeherwertigste byte steht dabei am anfang des lang-zahlen-speichers
;alle folgenden bytes werden dort angehangen
;V81
;IN_LEN und CMD_LEN zu 16bit zaehlern umgebaut, damit kann jede eingegebene zeichenkette
;2^16 zeichen lang sein
;V84
;BSC funktionen eingebaut
;ron, roff, sb, eb, trst
;in tap_out funktion in-befehl gegen push und pop getauscht, weil lesen von PIO_C kurzgeschlossene
;signale einlesen koennte
;BSC funktionen in zusammenhaengenden block am ende des programms verschoben
;V841
;int struktur SIO_A geaendert; SIO_A RX wird enabled oder disabled statt EI/DI
;cmd_pre_proc geaendert
;mem aufteilung geaendert
;V842
;OUT_LEN von 8 nach 16bit-zaehler umgebaut
;V85
;step mode eingebaut
;V851
;I2C-Funktionen ueberarbeitet
;V852
;kommentare entfernt
;receiveX_byte umbenannt nach I2Cx_RX
;zusatz: am ende von I2Cx_RX wird das empfangende byte mit ld a,c nach A kopiert
;ld a,c ist also nach ret nicht mehr noetig und somit auskommentiert
;BSC TAP1 TDI DAC schaltschwelle wird auf 40h geladen (ca. 1,3V)
;V853
;alle begriffe "burst" oder "B_" gegen "vector" getauscht
;ausgabe des input vektors an host in exec_vec verlagert
;funktion "set_step_mode" eingebaut
;begriffe "tap" gegen SP getauscht
;statt sh_in oder sh_out wird SIV oder SOV ausgegeben
;am ende von relseqon/off wartezeit eingefuegt
;aus V853 geht BSC V3.0 hervor
;V854
;alle BSC relevanten funktionen entfernt
;V855
;mem aufteilung geaendert
;pruefen ob funktion vm den long number bereicht ueberschreibt ! gelaehrt, max 52d zeichen stehen
;in STD_OUT
;kommentare entfernt
;pf befehl eingebaut, ohne echte funktionalitaet
;V856
;pf befehl fertig
;cmp befehl eingebaut
;ef befehl eingebaut
;cp befehl eingebaut
;fi befehl eingebaut
;V860
;mm befehl entfernt, wird durch fi ersetzt
;V861
;alte pio vereinbarungen entfernt
;vorbereitung der block transfer und suchbefehle nach req_snd verlegt
;cop_mem vereinfacht
;alle prozeduren fuer pf, ef, cp, cmp fi in programmende verlegt
;V862
;run befehl zu call umbenannt
;call mit option der startadresse ausgestattet
;ramsize check aus dld entfernt
;call befehl funktioniert ! Jer. 33,3 !
;temp0 variable eingebaut
;kommentare in herzschlagfunktion eingetragen
;einige textausgaben und befehle umbenannt
;V864
;in prgflash wird nicht mehr automatisch der flash geloescht
;copy befehl repariert
;prompt geaendert nach "cmd> "
;load mit option der zieladresse ausgestattet
;leerzeichen in textausgaben entfernt
;INI_PIO pueft nun status von D7 PIO B: wenn jumper auf JP1 Pin 17-18 wird
;adresse 8000h (im user prom) angesprungen, das ist kein call sondern ein jp !
;V865
;einige leerzeichen wieder eingebaut in textausgaben
;boot rom test eingebaut D1 von PIO A erzeugt bei fehler blinksignal an led0
;boot rom test auskommentiert wg. ? check sum ermittlung - baustelle
;V866
;RX_CHA_AVAILABLE bugfix: LD IY,ECHO_STS stand an der falschen stelle
;v867x
;alle call sio_a_ei/di auskommentiert (ausser in dld)
;ei wird in poll_cmd_cpl gemacht, nicht mehr in rx_cha_available
;DTR wird bei SIO_A_RESET aktiv
;RTS wird zu beginn von rx_cha_available inaktiv
;RTS wird am ende von in poll_cmd_cpl aktiv
;dld provisorisch repariert, geht nur ohne hw-flusssteuerung
;v868x
;dld auf hw-flusssteuerung umgestellt
;cts wird noch nicht abgefragt (in dld und rx_cha_available)
;v870x
;rx on first char in dld nicht machbar, weil /wait-verbindung sio a und cpu nicht da
;v871x
;/wait-verbindung prov gelegt
;RR0 wird in TX_EMP nicht explizit angewaehlt
;in TX_EMP wird nun RR1 bit 0 getestet
;ein block wird erfolgreich geladen in dld
;v873x
;dld laedt datei vollstaendendig !
;RAM_DATA_STS liegt statisch auf 1000h
;RAM_HID auskommentiert
;v874x
;block error counter eingebaut (auf 1009h)
;v875x
;1009h nicht verwendbar als bad block counter, nicht geklaehrt warum
;statt 1009h wird temp0 (1015h) verwendet
;bad blocks max 9. danach abbruch download
;bei Int routine upon RX overflow wird dld sauber beendet, kein neustart,
;kann aber nicht sicher getestet werden
;clear RAM DATA STS wird zu begin von download durchgefuehrt
;bad block counter wird nach erfolgreichem block transfer geloescht
;v876x
;kommentare entfernt
;i2c0 bus 1 test eingebaut
;pio test eingebaut
;v876
;bsc_V31
;variablen angepasst
;pio test entfernt
;i2c test entfernt
;download entfernt
;BSC_V32
;hw handshake optimiert: call	A_RTS_ON von rx_cha_available nach poll_cmd_cpl verlegt
;BSC_V33
;in ron und roff pausen auskommentiert
;BSC_V34
;call	TX_STR_TERM ueberall auskommentiert

OFFSET	equ	2000h
;OFFSET	equ	8000h
;OFFSET	equ	0h


CH0	equ	0h
CH1	equ	1h
CH2	equ	2h
CH3	equ	3h

SIO_A_D	equ	4h
SIO_A_C	equ	6h
SIO_B_D	equ	5h
SIO_B_C	equ	7h

PIO_A_D	equ	8h
PIO_A_C	equ	0Ah
PIO_B_D	equ	9h
PIO_B_C	equ	0Bh

PIO_C_D	equ	0Ch
PIO_C_C	equ	0Eh
PIO_D_D	equ	0Dh
PIO_D_C	equ	0Fh

PIO_E_D	equ	10h
PIO_E_C	equ	12h
PIO_F_D	equ	11h
PIO_F_C	equ	13h

RAM_BOT		equ	1800h+OFFSET	;lowest user RAM address

RAM_DATA_STS	equ	1000h	;holds 1 after successful download in RAM area
				;beginning at 1800h+OFFSET

;RAM_HID		equ	1000h		;lowest system RAM address
SCRATCH		equ	1001h 	;used by various functions
CMD_STS		equ	1002h	;holds status of cmd. 0=incomplete, 1=complete
PIO_A_MODE	equ	1003h	;holds current PIO A mode
PIO_A_IO_CONF	equ	1004h	;holds current IO configuration of PIO A

PIO_B_MODE	equ	1005h	;holds current PIO B mode
PIO_B_IO_CONF	equ	1006h	;holds current IO configuration of PIO B

RAM_TOP		equ	1007h	;here and at RAM_TOP+1 highest user RAM address stored
			;1008h	;highbyte of highest user RAM address
;BLK_ERR		equ	1009h	;number of garbled blocks during download
OUT_LEN		equ	100Bh	;holds length of output buffer (lowbyte)
			;100Ch 	;holds length of output buffer (highbyte)
ECHO_STS	equ	100Dh	;holds FFh if echo enabled, 0h if echo disabled

TEMP3		equ	100Eh	;used by heartbeat

SOURCE_ADR	equ	100Fh	;for flash programming: source address lowbyte
			;1010h	;source address highbyte
DEST_ADR	equ	1011h	;for flash programming: destination address lowbyte
			;1012h	;destination address highbyte
NUMB_OF_BYTES	equ	1013h	;for flash programming: number of bytes lowbyte
			;1014h	;number of byte highbyte
temp0		equ	1015h	;used by various functions, holds number of
				;unsuccessful block transfers/block during download
			;1016h	;highbyte of temp0
CMD_LEN 	equ	101Ch	;holds actual length of cmd in cmd buffer (lowbyte)
			;101Dh	;holds actual length of cmd in cmd buffer (highbyte)
IN_LEN		equ	101Eh	;holds length of of last cmd in input buffer (lowbyte)
			;101F	;holds length of of last cmd in input buffer (highbyte)

;BSC related:
CMD_PTR		equ	0EE00h	;start pos where cmd buffer begins, RX char become appended
				;req_number converts cmd buffer to integer NUMBER (see below)
				;max 32d characters allowed
				;so value in NUMBER may be as large as 16x8bit=128bit
STD_OUT		equ	0F200h	;start pos where TX chars are stored and appended, max 64d char
				;allowed
NUMBER		equ	0F600h	;start pos of long number storage
				;no protection agains stack corruption !
				;stack defaults to 1800h upon system start

;BSC related:
TDI1_BB		equ	1800h	;TDI1 bit buffer for temporarily usage
TDI1_BC		equ	1801h	;TDI1 bit counter for temporarily usage
V_TYPE		equ	1802h	;holds vector type: 01h for SDR, 02h for SIR

V_LEN1_BYTE	equ	1803h	;holds tap 1 vector lenght (in bytes) lowbyte
			;1804h	;holds tap 1 vector lenght (in bytes) highbyte
V_LEN2_BYTE	equ	1805h	;holds tap 2 vector lenght (in bytes) lowbyte
			;1806h	;holds tap 2 vector lenght (in bytes) highbyte

V_LEN1		equ	1807h	;holds tap 1 vector length lowbyte (unit is bit)
			;1808h	;holds tap 2 vector length highbyte (unit is bit)
V_LEN2		equ	1809h	;holds tap 2 vector length lowbyte (unit is bit)
			;180Ah	;holds tap 2 vector length highbyte (unit is bit)

STEP_MODE	equ	180Bh	;step mode: 0=tck wise, A=vector wise
TAP_SIG		equ	180Ch	;for temp. storage of tap signals
TCK_NR		equ	180Dh	;holds tck nr. lowbyte
			;180Eh	;holds tck nr. highbyte

V_IN1		equ	0F800h	;tap1 TDI input buffer
V_IN2		equ	0FA00h	;tap2 TDI input buffer

V_OUT1		equ	0FC00h	;start pos of output vector 1
V_OUT2		equ	0FE00h	;start pos of output vector 2

;-------------------------------------------------------------------------------








;-------PROG START UPON SYSTEM RESET BEGIN: ------------------------------------
	org	0+OFFSET
WARM_START:
	jp	INI_PIO

	;int vectors for cmd line mode
	org	0Ch+OFFSET
	DEFW	RX_CHA_AVAILABLE
	org	0Eh+OFFSET
	DEFW	SPEC_RX_CONDITON

	;int vectors for CTC
	org	16h+OFFSET
	DEFW	CT3_ZERO

	;int vectors for download mode:
;	org	1Ch+OFFSET
;	DEFW	BYTE_AVAILABLE
;	org	1Eh+OFFSET
;	DEFW	SPEC_BYTE_COND

	org	66h+OFFSET
	DEFW	NMI
NMI:	jp	WARM_START	;handle NMI as Master Reset



;-------PIO INIT begin-----------------------------
	org	0100h+OFFSET

INI_PIO:
	;init PIO A
	ld	a,04Fh		; set PIO A input mode
	out	(PIO_A_C),A
	ld	a,0FFh		; set D7..0 of output register H
	out	(PIO_A_D),A	;

	;init PIO B
	ld	A,0CFh		; set PIO B to bit mode
	ld	(PIO_B_MODE),A	; update global PIO B mode status variable
	out	(PIO_B_C),A

	ld	a,0FFh		; set D7..0 to input mode
	ld	(PIO_B_IO_CONF),A	;update global PIO B IO status variable
	out	(PIO_B_C),A	; write IO configuration into PIO B

	ld	A,0F0h		; SDA0, SCL0, SDA1, SCL1 = L
				; if direction of SDA or SCL changes to output
				; the pin will drive L
	out	(PIO_B_D),A	;loading PIO B output register

	in	A,(PIO_B_D)	;check status of PIO B D7
	bit	7,A		;when H proceed at INI_PIO_DONE
	jp	nz,INI_PIO_DONE	;when L
	;re-init PIO B
	ld	a,04Fh		; set PIO B input mode
	out	(PIO_B_C),A
	ld	a,0FFh		; set D7..0 of output register H
	out	(PIO_B_D),A	;
	jp	8000h		; jump to user prom bottom address
INI_PIO_DONE:


;ROM_TEST:
;	ld	E,06Fh	;load E with expected rom check sum
;	ld	HL,0h
;	ld	B,0h
;	sub	A	;A,B,HL cleared
;l_RT:	ld	A,B	;restore A from B
;	add	A,(HL)	;add A and data where HL points to
;	inc	HL	;advance HL
;	ld	B,A	;backup A in B
;	ld	A,H	;look if
;	cp	10h	;H has reached last ROM address +1
;	jp	nz,l_RT	;loop until H has reached last ROM address +1
;	ld	A,B	;restore A from B
;	cp	E	;compare A with expected rom check sum
;	jp	z,RT_END;if match proceed at RT_END

	;init PIO A
;	ld	a,0CFh		; set PIO A to bit mode
;	out	(PIO_A_C),A
;	ld	a,0FEh		; set D0 to output mode
;	out	(PIO_A_C),A	;
;	ld	a,0h		; set D0 L
;	out	(PIO_A_D),A
;	ld	B,0
;l_RT0:	djnz	l_RT0
;	jp	WARM_START
;RT_END:

;-------------------------------------------------------------
INI_SYS_VAR:
	ld	HL,1800h	; init stack pointer
	ld	SP,HL
	sub	A
;	ld	(BLK_ERR),A
	ld	(CMD_LEN),A	; reset CMD length counter
	ld	(CMD_LEN+1),A
	ld	(CMD_STS),A	; clear CMD status variable
	ld	(RAM_DATA_STS),A ; clear RAM DATA STS
	ld	(OUT_LEN),A	; clear STD_OUT length counter
	ld	(OUT_LEN+1),A
	dec	A
	ld	(ECHO_STS),A	; set ECHO ON

;----------------------------------------------------------------------


	;RESET all I2C-Busses
	call	RST_I2C0
	call	RST_I2C1

	;RESET BSC
	call	RST_BSC


;-------CTC INIT begin----------------------------------------------------------------------
INI_CTC:
	;init CH 1
	ld 	A,00000011b	; int off, timer on, prescaler=16, don't care ext. TRG edge,
				; start timer on loading constant, no time constant follows
				; sw-rst active, this is a ctrl cmd
	out 	(CH1),A		; CH1 is on hold now



	;init CH2
	;CH2 divides CPU CLK by (256*256) providing clock signal at TO2 at JP3:#11
	ld 	A,00100111b	; int off, timer on, prescaler=256, no ext. start,
				; start upon loading time constant, time constant follows
				; sw reset, this is a ctrl cmd
	out 	(CH2),A
	ld	A,0FFh		; time constant defined
	out 	(CH2),A		; and loaded into channel 2
				; T02 outputs 77Hz (at 5Mhz CPU CLK)


	;init CH3
	;CH3 is supplied by clock signal from TO2 via jumper at JP3:#11/13
	;CH3 divides TO2 clock by AFh
	;CH3 interupts CPU appr. every 2sec to service int routine CT3_ZERO (flashed LED D0/1)
	ld 	A,11000111b	; int on, counter on, prescaler don't care, edge don't care,
				; time trigger don't care, time constant follows
				; sw reset, this is a ctrl cmd
	out 	(CH3),A
	ld	A,0AFh		; time constant defined
	out 	(CH3),A		; and loaded into channel 3

	ld	A,10h		; it vector defined in bit 7-3,bit 2-1 don't care, bit 0 = 0
	out 	(CH0),A		; and loaded into channel 0



	;init CH0
	;CH0 provides SIO A RX/TX clock
	ld 	A,00000111b	; int off, timer on, prescaler=16, don't care ext. TRG edge,
				; start timer on loading constant, time constant follows
				; sw-rst active, this is a ctrl cmd
	out 	(CH0),A
	ld	A,1h		; time constant defined
	out 	(CH0),A		; and loaded into channel 0

				; TO0 outputs app. 10Mhz/2/16/(time constant)/16
				; which results in 19200 bits per sec
;-------CTC INIT done-----------------------------------------------------------------------











;-------SIO INIT begin----------------------------------------------------------------------
INI_SIO:
	call	SIO_A_RESET	;cares for WR4,5,1 settings

;-------SIO INIT done-----------------------------------------------------------------------












;-------CPU Interrupt setup begin----------------------------------------------------------
INT_INI:
	ld	BC,OFFSET
	ld	A,B
	ld	I,A	;load I reg with highbyte of OFFSET
	im	2	;enable int mode 2
	;di		;no int allowed yet, will be enabled later
	ei		;V841
;-------CPU Interrupt setup end------------------------------------------------------------














;-------MENUE begin------------------------------------------------------------------------
menu:
	ld	HL,Welcome	;TX welcome note
	call	TX_STR
	;call	TX_STR_TERM

	ld	HL,prompt	;TX prompt
	call	TX_STR
;	call	TX_STR_TERM





;-------CMD pre processor begin-------------------------------------------
CMD_pre_proc:
;	call	SIO_A_EI	;enable SIO_A interrupts
	call	poll_CMD_cpl	;loop here until CMD_STS=complete

;-------CMD pre processor end----------------------------------------------





;-------CMD post processor begin-------------------------------------------
CMD_post_proc:
	;verify cmd in cmd buffer against list of available cmds:

;BSC related:

	ld	HL,TRST
	call	PAR_CMD
	jp	nc,l_401


		call	tap_rst
		jp	EO_post_proc



l_401:
	ld	HL,REL_ON
	call	PAR_CMD
	jp	nc,l_411

		call	relseqon
		jp	EO_post_proc



l_411:
	ld	HL,REL_OFF
	call	PAR_CMD
	jp	nc,l_422

		call	relseqoff
		jp	EO_post_proc



l_422:
	ld	HL,SET_vec
	call	PAR_CMD
	jp	nc,l_413

		call	req_vec_par
		jp	EO_post_proc




l_413:
	ld	HL,EX_vec
	call	PAR_CMD
	jp	nc,l_402

		call	exec_vec
		jp	EO_post_proc



l_402:
	ld	HL,ST_MOD
	call	PAR_CMD
	jp	nc,l_400

		call	set_step_mode
		jp	EO_post_proc



;--------------------------------------
l_400:
	ld	HL,fill
	call	PAR_CMD
	jp	nc,l_16


		call	fill_mem
		jp	EO_post_proc



l_16:
	ld	HL,copy
	call	PAR_CMD
	jp	nc,l_15

		call	req_snd		;request source, number, destination address
		ldir
		jp	EO_post_proc



l_15:
	ld	HL,cmp
	call	PAR_CMD
	jp	nc,l_13

		call	req_snd		;request source, number, destination address
		call	cmp_mem		;compare mem blocks
		jp	EO_post_proc


l_13:
	ld	HL,erf
	call	PAR_CMD
	jp	nc,l_14

		call	id_check	;do id check of user flash prom
		call	prot_off	;disable sw protection
		call	fl_erase	;erase flash
		call	prot_on		;enable sw protection
		jp	EO_post_proc



l_14:
	ld	HL,PRG_FL
	call	PAR_CMD
	jp	nc,l_102

		call	req_snd		;request source, number, destination address
		call	id_check	;do id check of user flash prom
		call	prot_off	;disable sw protection
		;call	fl_erase	;erase flash
		call	fl_prog		;program flash
		call	prot_on		;enable sw protection
		jp	EO_post_proc


l_102:
	ld	HL,POUT
	call	PAR_CMD
	jp	nc,l_01

		ld	HL,io_adr
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get io address from host
		ld	C,A		;save io address in c
		push	BC
		ld	HL,io_dat
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get io data from host
		pop	BC		;restore io address in C
		out	(C),A		;output io data at io address
		jp	EO_post_proc


l_01:
	ld	HL,PIN
	call	PAR_CMD
	jp	nc,l_02A

		ld	HL,io_adr
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get io address from host
		ld	C,A		;save io address in c
		in	A,(C)
		push	AF		;backup value input from port on stack
		ld	HL,io_dat	;announce transmission of input value
		call	TX_STR
		pop	AF		;restore value input from port from stack
		call	APP_ACCU	;append value to STD_OUT
		call	TX_STD_OUT	;TX input value to host
		jp	EO_post_proc


l_02A:
;	ld	HL,pio_test
;	call	PAR_CMD
;	jp	nc,l_02

;		call	p_test
;		jp	EO_post_proc


l_02:
	ld	HL,RAM_S		;see comments at label l_0 and following
	call	PAR_CMD
	jp	nc,l_4

		call	RAM_SIZE_CHK
;		call	TX_STR_TERM
		jp	EO_post_proc




l_4:
;	ld	HL,DLD		;see comments at label l_0 and following
;	call	PAR_CMD
;	jp	nc,l_41

;		call	req_d	;ask host for destination address
;		ld	HL,AWT_TRM
;		call	TX_STR	;request user to transmit file per xmodem
;		call	TX_STR_TERM
;		call	DWNLD	;download file
;		call	TX_STR_TERM
;		jp	EO_post_proc




l_41:	ld	HL,HELP		;see comments at label l_0 and following
	call	PAR_CMD
	jp	nc,l_42

		ld	HL,CMD_SET
		call	TX_STR
;		call	TX_STR_TERM
		jp	EO_post_proc




l_42:	ld	HL,EO
	call	PAR_CMD
	jp	nc,l_5

		sub	A
		ld	(ECHO_STS),A
		jp	EO_post_proc
	


	

l_5:	ld	HL,VIEW_MEM	;see comments at label l_0 and following
	call	PAR_CMD
	jp	nc,l_8

		ld	HL,mem_adr16
    		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;ask host for 16 bit number
		call	READ_MEM
		jp	EO_post_proc




l_8:	ld	HL,ca_usr_prg		;see comments at label l_0 and following

	call	PAR_CMD
	jp	nc,l_9

		ld	HL,mem_adr16
    		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;ask host for user program start address
		ld	(temp0),HL	;backup start address in temp0
		ld	HL,l_ret	;load user program return 
		push	HL		;address on stack
		ld	HL,(temp0)	;restore user program start address in HL
		jp	(HL)		;jump to user program
l_ret:		jp	EO_post_proc






l_9:	ld	HL,RSTI2C0
	call	PAR_CMD
	jp	nc,l_91

		;resetting i2c0 bus:
		call	RST_I2C0	;do 10 x LHL on SCL0 while SDA0 = H
		call	SCL0_IN		;SCL0 = H
		jp	EO_post_proc




	

l_91:	ld	HL,RSTI2C1
	call	PAR_CMD
	jp	nc,l_921

		;resetting i2c1 bus:
		call	RST_I2C1	;do 10 x LHL on SCL1 while SDA1 = H
		call	SCL1_IN		;SCL1 = H
		jp	EO_post_proc



l_921:
;	ld	HL,i2c1_test
;	call	PAR_CMD
;	jp	nc,l_10

;		call	i1test

;		jp	EO_post_proc





l_10:	ld	HL,I2C0P		;access to i2c pio devices
	call	PAR_CMD
	jp	nc,l_112

		call	I2C0_START

		ld 	HL,p0_sel	;request select code from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get select code from host
		push	AF

		;send 8bit device address to slave:
		call	I2C0_tx
		jp	nc,EO_post_proc

		pop	AF	; check for write or read access requested by host
		bit	0,A			
		jp	z,l_651

		ld 	HL,p0_in	;anounce transmission of read value to host
		call	TX_STR
		call	I2C0_RX		; returns with slave data byte in C
			
		;transmit data byte to host
		;ld	A,C
		call	APP_ACCU	;append value to STD_OUT
		call	TX_STD_OUT	;TX input value to host

		call	I2C0_STOP
		jp	EO_post_proc

	
		;write access follows:
				
l_651:		;write byte into slave
		ld 	HL,p0_out	;request output value from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get output value from host
		call	I2C0_tx
		jp	nc,EO_post_proc

		call	I2C0_STOP
		jp	EO_post_proc
		



l_112:
	ld	HL,I2C1P		;access to i2c pio devices
	call	PAR_CMD
	jp	nc,l_11

		call	I2C1_START

		ld 	HL,p1_sel	;request select code from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get select code from host
		push	AF

		;send 8bit device address to slave:
		call	I2C1_tx
		jp	nc,EO_post_proc

		pop	AF
		bit	0,A	; check for write or read access requested by host
		jp	z,l_652

		ld	HL,p1_in	;anounce transmission of read value to host
		call	TX_STR
		call	I2C1_RX	; returns with slave data byte in C

		;transmit data byte to host
		;ld	A,C
		call	APP_ACCU	;append value to STD_OUT
		call	TX_STD_OUT	;TX input value to host
		
		call	I2C1_STOP
		jp	EO_post_proc

	
		;write access follows:
				
l_652:		;write byte into slave
		ld 	HL,p1_out	;request output value from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get output value from host
		call	I2C1_tx
		jp	nc,EO_post_proc

		call	I2C1_STOP
		jp	EO_post_proc




	

l_11:	ld	HL,I2C0F		;access to i2c flash devices
	call	PAR_CMD
	jp	nc,l_110

		call	I2C0_START

		ld	HL,f0_sel	;request device select code from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get device select code from host
		push	AF

		res	0,A		; clear LSB to indicate write access to slave
		call	I2C0_tx
		jp	nc,EO_post_proc

		ld	HL,f0_adr	;request memory address from host
		call	TX_STR
;  		call	TX_STR_TERM
		call	req_number	;get memory address from host
		call	I2C0_tx
		jp	nc,EO_post_proc

		pop	AF		; check for write or read access requested by host
		push	AF
		bit	0,A			
		jp	z,l_65
				
		;read access follows:

		;restart I2C bus 0
		call	SCL0_IN		;SCL0 = H
		call	I2C0_START

		;resend 8bit device select code
		pop	AF		
		call	I2C0_tx
		jp	nc,EO_post_proc

		ld	HL,f0_dar	; anounce transmission of read byte to host
		call	TX_STR	
		call	I2C0_RX	; returns with slave data byte in C

		;forward data byte to host
		;ld	A,C
		call	APP_ACCU	;append value to STD_OUT
		call	TX_STD_OUT	;TX input value to host
		call	I2C0_STOP
		jp	EO_post_proc
				
l_65:		;write byte into slave
		ld	HL,f0_daw	;request byte to be written from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get byte to be written from host
		
		call	I2C0_tx
		jp	nc,EO_post_proc

		call	I2C0_STOP
		jp	EO_post_proc




l_110:	ld	HL,I2C1F		;access to i2c flash devices
	call	PAR_CMD
	jp	nc,l_100

		call	I2C1_START

		ld	HL,f1_sel	;request device select code from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get device select code from host
		push	AF

		;send 8bit device select code to slave:
		res	0,A		; clear LSB to indicate write access to slave
		call	I2C1_tx
		jp	nc,EO_post_proc

		ld	HL,f1_adr	;request memory address from host
		call	TX_STR
;		call	TX_STR_TERM
		call 	req_number	;get memory address from host
		call	I2C1_tx
		jp	nc,EO_post_proc

		pop	AF		; check for write or read access requested by host
		push	AF
		bit	0,A
		jp	z,l_653

		;read access follows:

		;restart I2C bus 1
		call	SCL1_IN		;SCL1 = H
		call	I2C1_START

		;resend 8bit device select code
		pop	AF
		call	I2C1_tx
		jp	nc,EO_post_proc

		ld	HL,f1_dar	;anounce transmission of data read to host
		call	TX_STR
		call	I2C1_RX	; returns with slave data byte in C

		;forward data byte to host
		;ld	A,C
		call	APP_ACCU	;append value to STD_OUT
		call	TX_STD_OUT	;TX input value to host
		call	I2C1_STOP
		jp	EO_post_proc


l_653:		;write byte into slave
		ld	HL,f1_daw	;request byte to be written from host
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get byte to be written from host

		call	I2C1_tx
		jp	nc,EO_post_proc

		call	I2C1_STOP
		jp	EO_post_proc





	;--------------------------------------------------------------
l_100:	;process any other command this way:
;	call	wait_2
	ld	HL,error	;TX "unkown cmd"
	call	TX_STR
;	call	TX_STR_TERM
	
EO_post_proc:
;	call	wait_2
	ld	HL,prompt		;TX "prompt"
	call	TX_STR
;	call	TX_STR_TERM
	jp	CMD_pre_proc	;go checking CMD_STS

	
	;-------CMD parsing begin--------------------------------------------------
	;requires HL pointing to CMD to be parsed
PAR_CMD:
	ld	DE,CMD_PTR
l_51:
	ld	A,(DE)
	CPI
	jp	nz,l_52 ;if mismatch of first char in cmd buffer, do next parsing
	inc	DE	;prepare next char in cmd buffer		
	cp	0Dh	;check for end of cmd (CR)	
	jp	nz,l_51		;if end of cmd reached
				;and start cmd execution:
				
				;sending of NEW_LINE here removed with V80
				
	scf		;if match return with carry set
	RET

l_52:	scf
	ccf		;if mismatch return with carry cleared
	RET
	;-------CMD parsing end--------------------------------------------------

;-------CMD post processor end-------------------------------------------------------------------------

















;-------I2C SUBROUTINES BEGIN---------------------------------------------
;transmits byte to I2C device on bus 0
;returns with carry cleared if ackn bit not found
;modifies A,B,C,D,HL
I2C0_tx:	call	send0_byte
		bit	1,D		; test D register for acknowledge bit
		scf
		ret	z		;return if akn bit = L with carry set
		;when ACK error on bus - transmit error message to host and stop bus
		call	TX_error
		call	I2C0_STOP
		scf
		ccf
		ret			;return if akn bit = H with carry cleared

I2C1_tx:	call	send1_byte
		bit	3,D		; test D register for acknowledge bit
		scf
		ret	z		;return if akn bit = L with carry set
		;when ACK error on bus - transmit error message to host and stop bus
		call	TX_error
		call	I2C1_STOP
		scf
		ccf
		ret			;return if akn bit = H with carry cleared



RST_I2C0:	;modifies A, B, D
		;SDA0 must be H for proper reset
		;leaves SDA0 = H and SCL0 = H
		ld	B,0Ah	    ; do 10 SCL0 cycles while SDA0 is H
l_77:		call	SCL0_CYCLE
		djnz	l_77
		call	SCL0_IN
		ret

RST_I2C1:	;modifies A, B, D
		;SDA1 must be H for proper reset
		;leaves SDA1 = H and SCL1 = H
		ld	B,0Ah	    ; do 10 SCL1 cycles while SDA0 is H
l_771:		call	SCL1_CYCLE
		djnz	l_771
		call	SCL1_IN
		ret

SCL0_CYCLE:	;modifies A
		;returns D wherin bit 1 represents status of SDA0 while
		;SCL0 was H
		;leaves SCL0 = L
		call	SCL0_OUT
		call	SCL0_IN
		
		;look for ackn bit
		in	A,(PIO_B_D)
		ld	D,A
		call	SCL0_OUT
		ret

SCL1_CYCLE:	;modifies A
		;returns D wherin bit 3 represents status of SDA1 while
		;SCL1 was H
		;leaves SCL1 = L
		call	SCL1_OUT
		call	SCL1_IN
		
		;look for ackn bit
		in	A,(PIO_B_D)
		ld	D,A
		call	SCL1_OUT
		ret

SDA0_IN:	;modifies A	    
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SDA0 to input
		ld	A,(PIO_B_IO_CONF)
		set	1,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SDA1_IN:	;modifies A	    
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SDA1 to input
		ld	A,(PIO_B_IO_CONF)
		set	3,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret
	
SDA0_OUT:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SDA0 to output
		ld	A,(PIO_B_IO_CONF)
		res	1,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SDA1_OUT:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SDA1 to output
		ld	A,(PIO_B_IO_CONF)
		res	3,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SCL0_IN:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SCL0 to input
		ld	A,(PIO_B_IO_CONF)
		set	0,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SCL1_IN:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SCL1 to input
		ld	A,(PIO_B_IO_CONF)
		set	2,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SCL0_OUT:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SCL0 to output
		ld	A,(PIO_B_IO_CONF)
		res	0,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

SCL1_OUT:	;modifies A
		;reload PIO B mode
		ld	A,(PIO_B_MODE)
		out	(PIO_B_C),A
		;change direction of SCL1 to output
		ld	A,(PIO_B_IO_CONF)
		res	2,A
		out	(PIO_B_C),A
		ld	(PIO_B_IO_CONF),A
		ret

send0_byte:	;requires value to be sent in A
		;returns with bit 1 of D holding status of ACKN bit
		;and SCL0 = L and SDA0 = H
		;modifies A, B, C, D
		ld	B,8h		; 8 bits are to be clocked out
		ld	C,A		; copy to C reg
l_74:		sla	C		; shift MSB of C into carry
		jp	c,SDA0_H	; when L
SDA0_L:		call	SDA0_OUT	; pull SDA0 low
		jp	l_75
SDA0_H:		call	SDA0_IN		; release SDA0 to let it go high
l_75:		call	SCL0_CYCLE	; do SCL0 cycle (LHL)
		djnz	l_74		; process next bit of C reg
		call	SDA0_IN		; release SDA0 to let it go high
		call	SCL0_CYCLE	; do SCL0 cycle (LHL), bit 1 of D holds ackn bit
		ret

send1_byte:	;requires value to be sent in A
		;returns with bit 3 of D holding status of ACKN bit
		;and SCL1 = L and SDA1 = H
		;modifies A, B, C, D
		ld	B,8h		; 8 bits are to be clocked out
		ld	C,A		; copy to C reg
l_741:		sla	C		; shift MSB of C into carry
		jp	c,SDA1_H	; when L
SDA1_L:		call	SDA1_OUT	; pull SDA1 low
		jp	l_751
SDA1_H:		call	SDA1_IN		; release SDA1 to let it go high
l_751:		call	SCL1_CYCLE	; do SCL1 cycle (LHL)
		djnz	l_741		; process next bit of C reg
		call	SDA1_IN		; release SDA1 to let it go high
		call	SCL1_CYCLE	; do SCL1 cycle (LHL), bit 3 of D holds ackn bit
		ret

I2C0_RX:	;modifies A, B, D
		;returns with slave data byte in C
		;leaves SCL0 = L and SDA0 = H
		ld	B,8h
l_66:		in	A,(PIO_B_D)
		scf
		bit	1,A
		jp	nz,H0_found	
L0_found:	ccf
H0_found:	rl	C
		call	SCL0_CYCLE
		djnz	l_66
		call	SCL0_CYCLE	;send NAK to slave
		;byte ready in C
		ld	A,C
		ret


I2C1_RX:	;modifies A, B, D
		;returns with slave data byte in C
		;leaves SCL1 = L and SDA1 = H
		ld	B,8h
l_661:		in	A,(PIO_B_D)
		scf
		bit	3,A
		jp	nz,H1_found	
L1_found:	ccf
H1_found:	rl	C
		call	SCL1_CYCLE
		djnz	l_661
		call	SCL1_CYCLE	;send NAK to slave
		;byte ready in C
		ld	A,C
		ret


I2C0_START:	;start I2C bus 0
		call	SDA0_OUT	;SDA = L
		call	SCL0_OUT	;SCL = L
		ret

I2C1_START:	;start I2C bus 1
		call	SDA1_OUT	;SDA = L
		call	SCL1_OUT	;SCL = L
		ret


I2C0_STOP:	;stop I2C bus 0
		call	SDA0_OUT
		call	SCL0_IN
		call	SDA0_IN	
		;jp	EO_post_proc
		ret

I2C1_STOP:	;stop I2C bus 1
		call	SDA1_OUT
		call	SCL1_IN
		call	SDA1_IN	
		;jp	EO_post_proc
		ret


;-------I2C SUBROUTINES END------------------------------------------





TX_error:
		ld	HL,error	; TX error message to host
		call	TX_STR
;		call	TX_STR_TERM
		ret




;-------Int. Routine for CT3 zero count begin------------------------------
CT3_ZERO:
	;flashes D0 and D1 as 2 bit binary counter
	push	AF

	ld	A,0CFh
	out	(PIO_A_C),A	;set PIO A to bit mode
	ld	A,0FCh
	out	(PIO_A_C),A	;set io configuration: A0 and A1 are outputs
	ld	A,(TEMP3)
	inc	A		;inc temp3 content
	out	(PIO_A_D),A	;load temp3 onto pio port A
	ld	(TEMP3),A	;save temp3

	pop	AF
	EI		;came with V784
	reti
;-------Int. Routine for CT3 zero count begin------------------------------








;-------SIO INTERRUPT ROUTINES for cmd line mode BEGIN-----------------------------------------


;-------Int Routine upon RX charcter begin-------------------------------------------------
RX_CHA_AVAILABLE:
;	ei			;in V841
	push	AF		;backup AF
	call	A_RTS_OFF
;	ld	a,005h		;write into WR0: select WR5
;	out	(SIO_A_C),A
;	ld	a,0E8h		;DTR active, TX 8bit, BREAK off, TX on, RTS inactive
;	out	(SIO_A_C),A


	in	A,(SIO_A_D)	;read RX character into A
	;push	AF		;backup RX character
	; A holds received character

	;add RX character to string in cmd buffer:
	ld	BC,(CMD_LEN)	;BC holds current length of command
	ld	HL,CMD_PTR	;set HL at begin of cmd buffer
	add	HL,BC		;HL now holds pos to store RX char in
	;pop	AF		;restore RX char in A
	ld	(HL),A		;write RX char where HL points to

	ld	IY,ECHO_STS	; IY points to ECHO_STS

	;examine RX character:
	cp	0Dh		;was last RX char a CR ?
	jp	z,RX_CR
	cp	08h		;was last RX char a BSP (backspace) ?
	jp	z,RX_BSP

	;for any other character:

	;if ECHO_STS=FFh TX received char back to host
;	ld	IY,ECHO_STS
	rrc	(IY+0)		;each rotating of FFh sets carry
	jp	nc,l_212	;if ECHO_STS<>FFh don't echo an proceed at l_212
				;echo character (HL still points at char received last)
	out	(SIO_A_D),A	;to host
	call	TX_EMP

l_212:
	inc	BC
	ld	(CMD_LEN),BC	;CMD_LEN holds current lenght of command
	;sub	A		;comm. in V841
	;ld	(CMD_STS),A	;comm. in V841 ;set or leave CMD status  "incomplete"
;	call	A_RTS_ON	;V32
	jp	eo_rx_cha_ava
;	pop	AF
;	reti



	;-------process cr character begin----------
RX_CR:
;	call	SIO_A_DI

	rrc	(IY+0)		;each rotating of FFh sets carry
	jp	nc,l_220	;if ECHO_STS<>FFh don't TX line feed an proceed at l_220
				;(ECHO is ON if ECHO_STS=FFh)

	ld	HL,NEW_LINE	;transmit new line
	call	TX_STR
	ld	BC,(CMD_LEN)	;TX_STR modifies BC, so restore BC from CMD_LEN

l_220:  ld	(IN_LEN),BC	;copy CMD_LEN into IN_LEN

	ld	A,1
	ld	(CMD_STS),A	;set CMD status to "complete"
;	call	SIO_A_DI	;disable SIO_A interrupts ;in V841

	sub	A
	ld	(CMD_LEN),A	;clear CMD_LEN
	ld	(CMD_LEN+1),A

;	call	A_RTS_OFF
	jp	eo_rx_cha_ava

;	pop	AF		;restore AF
;	reti			;leave procedure but do not enable interupts
	;-------process cr character end---------------



	;-------process backspace charcter begin-----------
RX_BSP:	ld	HL,0FFFFh
	add	HL,BC			;carry is set if CMD_LEN>0
	jp	nc,END_OF_RX_BSP	;do not BACKSPACE if CMD_LEN=0

	dec	BC		;if CMD_LEN>0 then CMD_LEN-1
	ld	(CMD_LEN),BC	;update CMD_LEN

	ld	HL,BS_SP_BS
	call	TX_STR
;	call	A_RTS_ON	;V32

END_OF_RX_BSP:
	;sub 	A		;comm. in V841
	;ld	(CMD_STS),A	;comm. in V841 ;set or leave CMD status  "incomplete"
;	pop	AF
;	reti
	;-------process backspace character end-----------

eo_rx_cha_ava:
;	call	A_RTS_ON
	pop	AF
;	ei
	reti

;-------Int Routine upon RX charcter end---------------------------------------------------



;-------poll CMD_STS loop------------------------------
	;waits until "cmd complete"
	;modifies all registers
poll_CMD_cpl:
;	call	SIO_A_RESET
	call	A_RTS_ON
l_690:
	ei
	call	A_RTS_ON	;V32
	halt
	ld	A,(CMD_STS)
	cp	1h		;poll for "cmd complete"
	jp	nz,l_690

;	di
	sub	A
	ld	(CMD_STS),A
;	call	A_RTS_OFF
;	call	SIO_A_DI
	RET






;-------Int routine upon special RX condition begin---------------------
SPEC_RX_CONDITON:
	jp	WARM_START
;-------Int Routine upon special RX condition end--------------------------





SIO_A_RESET:
	;set up TX and RX:
	ld	a,00110000b	;write into WR0: error reset, select WR0
	out	(SIO_A_C),A

	ld	a,018h		;write into WR0: channel reset
	out	(SIO_A_C),A

	ld	a,004h		;write into WR0: select WR4
	out	(SIO_A_C),A
	ld	a,44h		;44h write into WR4: clkx16,1 stop bit, no parity
	out	(SIO_A_C),A

	ld	a,005h		;write into WR0: select WR5
	out	(SIO_A_C),A
	ld	a,0E8h		;DTR active, TX 8bit, BREAK off, TX on, RTS inactive
	out	(SIO_A_C),A

	ld	a,01h		;write into WR0: select WR1
	out	(SIO_B_C),A
	ld	a,00000100b	;no interrupt in CH B, special RX condition affects vect	
	out	(SIO_B_C),A

	ld	a,02h		;write into WR0: select WR2
	out	(SIO_B_C),A
	ld	a,0h		;write into WR2: cmd line int vect (see int vec table)
				;bits D3,D2,D1 are changed according to RX condition
	out	(SIO_B_C),A

	ld	a,01h		;write into WR0: select WR1
	out	(SIO_A_C),A
	ld	a,00011000b	;interrupt on all RX characters, parity is not a spec RX condition
				;buffer overrun is a spec RX condition
	out	(SIO_A_C),A

SIO_A_EI:
	;enable SIO channel A RX
	ld	a,003h		;write into WR0: select WR3
	out	(SIO_A_C),A
	ld	a,0C1h		;RX 8bit, auto enable off, RX on
	out	(SIO_A_C),A	
	;Channel A RX active
	RET


SIO_A_DI:
	;disable SIO channel A RX
	ld	a,003h		;write into WR0: select WR3
	out	(SIO_A_C),A
	ld	a,0C0h		;RX 8bit, auto enable off, RX off
	out	(SIO_A_C),A	
	;Channel A RX inactive
	ret

A_RTS_OFF:
	ld	a,005h		;write into WR0: select WR5
	out	(SIO_A_C),A
	ld	a,0E8h		;DTR active, TX 8bit, BREAK off, TX on, RTS inactive
	out	(SIO_A_C),A
	ret
	
A_RTS_ON:
	ld	a,005h		;write into WR0: select WR5
	out	(SIO_A_C),A
	ld	a,0EAh		;DTR active, TX 8bit, BREAK off, TX on, RTS active
	out	(SIO_A_C),A
	ret



;-------SUBROUTINES BEGIN-------------------------------------------
;-asks host for a number
;-smallest unit is BYTE (so host must send at least 2 characters)
;-half bytes are not accepted (e.g. it is invalid if host sends "123")
;-in case of invalid input a return to EO_post_proc is performed (by manipulation of stack) !
;-does not check content of characters (e.g. result of sending "nice" is unknown)
;-the result of the last 2 characters in this number is returned in A
;-the result of the last 4 characters in this number is returned in HL, wherein H holds high
; byte and L holds low byte:
; (e.g. sending "123456" returns A holding 56h, and HL holding 3456h)
; all other characters get lost
;-modifies all registers except the background registers
;-loads every converted byte into long number storage (lowbyte at lowest address)

req_number:	;call 	set_CMD_incpl	;clear CMD status	;comm. V841
		;call	SIO_A_EI
		;ei			;comm. V841
		call	poll_CMD_cpl
		ld	A,(IN_LEN)	;get lowbyte of IN_LEN
		srl	A		;divide by 2 / A holds number of words in input buffer
		ld	B,A		;copy into B
		jp	nc,l_133	;if IN_LEN was odd	
		ld	HL,error	;TX ..?	
		call	TX_STR
		ld	HL,EO_post_proc	;replace return address on stack by address of EO_post_proc
		inc	SP
		inc	SP
		push	HL		
		ret			;and return
		
l_133:		ld	DE,CMD_PTR
		ld	IX,NUMBER	;IX points to beginning of long number storage
l_132:		push	BC		;backup number of words on stack
		call	conv_RX_2ASC2BIN;convert word in input buffer to byte , DE points to word
					;A holds result
		ld	(IX+0),A	;load A into long number storage
		inc	IX		;advance pointer of long number storage by 1
		inc	DE		;advance DE by two
		inc	DE		;so that it point to next word in input buffer
		pop	BC		;restore number of words from stack
		bit	0,B		;check for last cycle: bit 0 of counter is set in last cycle
		jp	nz,l_135
		ld	H,A
l_135:		djnz	l_132		;loop to l_132 until all words are read from buffer
		ld	L,A
		ret			;return
				








;-----------------------------------------------------


TX_STR_TERM:
	;modifies HL, A
	ld	HL,STR_TERM
	call	TX_STR
	ret
	
	
TX_STD_OUT:
	ld	HL,STD_OUT
	call	TX_STR
;	call	TX_STR_TERM
	ret

TX_STR: ;TX string, HL points to first byte address
	;modifies A, HL , BC
TX_CHA:	ld	a,(HL)
	out	(SIO_A_D),A
	call	TX_EMP
;	call	host_rdy
	sub	a
	cpi		;look for string termination character 0h
	jp	nz,TX_CHA
	ld	(OUT_LEN),A	;set output string length lowbyte to 0
	ld	(OUT_LEN+1),A	;set output string length highbyte to 0
	ret


TX_EMP:	; check for TX buffer empty
	;modifies A
	sub	a		;clear a, write into WR0: select RR0
	inc	a		;select RR1
	out	(SIO_A_C),A
	in	A,(SIO_A_C)		;read RRx
	bit	0,A
	jp	z,TX_EMP
	ret
	
host_rdy:
	ld	a,10h		; write cmd 2 into WR0: select RR0
	out	(SIO_A_C),A
l_551:	in	A,(SIO_A_C)		;read RR0
	bit	5,A	;when host ready bit 5 (CTS) is H
	jp	z,l_551
	ret
	
;---------------------------------------------------









;-------delay----------------

WAIT_2:	; delay
	push	AF
	push	BC
	push	DE
	ld	de,0500h
l_W20:	djnz	l_W20
	dec 	de
        ld     	a,d
        or     	a      ;update zero flag
	jp	nz,l_W20
	pop	DE
	pop	BC
	pop	AF
        ret










;-------convert 2 received ASCII char to byte begin-----------------------------
;	DE points to input in CMD_PTR and CMD_PTR+1
;	output in A
;	modifies A, B  
conv_RX_2ASC2BIN:
		;ld	DE,CMD_PTR	;read first char in cmd buffer
		push	DE		;came with V783
		ld	A,(DE)
		bit	6,A
		jp	z,hi_ni_09	;if bit 6 not set,it's below Ah
		add	A,9h
		jp	sh_4xl
hi_ni_09:	sub	30h		;convert to 4 bit number
sh_4xl:		sla	A
		sla	A
		sla	A
		sla	A
		ld	B,A		;B[7..4] hold high nibble 

		inc	DE		;read 2nd char in cmd buffer
		ld	A,(DE)
		bit	6,A
		jp	z,lo_ni_09	;if bit 6 not set,it's below Ah
		add	A,9h
		and	0Fh
		jp	EO_conv_RX_2ASC2BIN
lo_ni_09:	sub	30h		;convert to 4 bit number

EO_conv_RX_2ASC2BIN:
		or	B		;A holds result
		pop	DE		;came with V783
		RET
;-------convert 2 received ASCII char to byte end----------------------------





;-------convert byte to 2 ASCII char begin---------------------------
;	input value in A
;	output high nibble in D, low nibble in C
; modifies A,BC,D

conv_BYTE2ASC:
		ld	C,A		;backup given byte in C

proc_hi_ni:	;process high nibble
		and	0F0h		;clear low nibble
		srl	A		;move high nibble into low nibble
		srl	A
		srl	A
		srl	A
		
		ld	B,A		;backup A in B
		ld	A,9		
		sub	B
		jp	c,ni_AF		;nibble > 9 ?
		ld	A,B		;restore nibble
		add	A,30h		;add 30h to make ASCII char
		jp	hi_ni_rdy
ni_AF:		ld	A,B		;restore nibble
		add	A,37h		;add 40h-9h to make ASCII char
hi_ni_rdy:	ld	D,A		;high nibble ready in D


		;process low nibble
		ld	A,C		;restore given byte from C
		and	0Fh		;clear high nibble
		ld	B,A		;backup A in B
		ld	A,9		
		sub	B
		jp	c,ni_AF2	;nibble > 9 ?
		ld	A,B		;restore nibble
		add	A,30h		;add 30h to make ASCII char
		jp	lo_ni_rdy
ni_AF2:		ld	A,B		;restore nibble
		add	A,37h		;add 40h-9h to make ASCII char
lo_ni_rdy:	ld	C,A		;low nibble ready in C
					;high nibble ready in D
		RET		
;-------convert byte to 2 ASCII char end---------------------------











;-------RAM size check begin---------------------------------
RAM_SIZE_CHK:

	ld	HL,RAM_BOT	;get RAM bottom as start value
    	scf			;set carry flag
	ccf			;comlpement carry flag
l_ER0:	
	ld	B,1h		;walking one starts at LSB
WALK_1:	
	ld	A,B		;copy to A
	ld	(HL),A		;write shift value into RAM
	ld	A,(HL)		;read shift value back from RAM
	cp	B
	jp	nz,RAM_RANGE	;if mismatch, top of RAM+1 reached
	sla	B
	jp	nc,WALK_1

	sub	A		;clean up RAM location
	ld	(HL),A

	inc	HL		;inc RAM address
	jp	l_ER0
		
RAM_RANGE:
	dec	HL		;last checked address - 1
	ld	(RAM_TOP),HL
	ld	A,H
	call	APP_ACCU
	ld	HL,(RAM_TOP)
	ld	A,L
	call	APP_ACCU
	call	TX_STD_OUT
	ret	
;--------RAM size check end -----------------------------------------------







;--------------------------------------------------------------------------
APP_ACCU:
	;converts A content into 2 ASCII characters in C and D
	;C holds low nibble, D holds high nibble
	;appends characters in C and D to STD_OUT
	;appends 0h as string termination
	;increments OUT_LEN by two
	;modifies A,BC,DE,IX,IY

	call	conv_BYTE2ASC	;converts A to 2xASCII chars in D and C
	ld	B,C
	ld	C,D		;high nibble in C, low nibble in B
	scf			;set carry flag
APP_CHAR:
	;requires char to append in C
	;returns at label l_933 if carry not set
	push	AF		;backup carry status
	ld	IX,STD_OUT	;IX points to STD_OUT begin
	;ld	A,(OUT_LEN)	;get current output string length
	ld	DE,(OUT_LEN)	;get current output string length
	ld	IY,OUT_LEN	;IY points to OUT_LEN
	;ld	D,0h
	;ld	E,A
	add	IX,DE		;IX points to last pos in string

	ld	(IX+0),C	;append C to string
	inc	(IY+0)		;OUT_LEN+1
	ld	(IX+1),0h	;append termination string
	pop	AF		;restore carry status
l_933:	ret	nc		;return if carry not set

	ld	(IX+1),B	;else append B to string (overwrite former termination)
	inc	(IY+0)		;OUT_LEN+1
	ld	(IX+2),0h	;append termination to string
	RET

;---------------------------------------------------------------------



READ_MEM:	;reads memory content starting where HL points to
		;transmits row by row, so STD_OUT holds max.  52d characters
		;modifies all registers !
		ld	B,10h		;read 16 lines
RD_HL_ROW:	push	BC

		;load first address of first row in STD_OUT
		ld	A,H		;append high byte of mem address
		EXX			;backup HL in background register
		call	APP_ACCU
		EXX			;restore HL from background register
		ld	A,L		;append low byte of mem address
		EXX			;backup HL in background register
		call	APP_ACCU
		scf			;add space character
		ccf
		ld	C,020h
		call	APP_CHAR
		EXX			;restore HL from background register
		;first address of first row ready in STD_OUT
		
		ld	B,10h		;read 16 columns
RD_HL_COL:	ld	A,(HL)		;read memory content into A
		EXX			;backup HL in background register
		call	APP_ACCU
		scf			;append space character
		ccf
		ld	C,020h
		call	APP_CHAR
		EXX			;restore HL from background register
		inc	HL		;HL points to next mem position	
		djnz	RD_HL_COL	;loop until 16 columns are read
		EXX			;backup HL in background register
		call	TX_STD_OUT	;TX row to host
		ld	HL,NEW_LINE	;transmit new line
		call	TX_STR
		EXX			;restore HL from background register
		pop	BC		;restore BC from stack
		djnz	RD_HL_ROW	;loop until 16 rows are read
		ret

;----------------------------------------------------------------------------
div_by_2:	
;divides content of BC by 2
;writes the result back into BC !
;modifies BC
		srl	B
		jp	c,l_713
		srl	C
		ret
l_713:		srl	C
		set	7,C
		ret


	

;----------------------------------------------------------------------------
TX_NUMBER:
;transfers long number to host
;HL points to low byte of number
;BC holds number of bytes
;modifies A, HL, BC
		add	HL,BC		
l_844:		dec	HL		;HL points to high byte of number
		ld	A,(HL)
		push	BC
		call	APP_ACCU	;append byte to STD_OUT
		pop	BC
		dec	BC		;number of bytes - 1
		ld	A,B
		cp	0		;test high byte of BC for 0
		jp	nz,l_844	;if yes,
		ld	A,C		
		cp	0		;test low byte of BC for 0
		jp	nz,l_844	;if yes,
		call	TX_STD_OUT	;TX input value to host
		ret
;-----------------------------------------------------------------------------




req_snd:	;requests source, number, destination address
		ld	HL,source16
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get source address from host
		ld	(SOURCE_ADR),HL
req_nd:
		ld	HL,count16
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get number of bytes to burn from host
		ld	(NUMB_OF_BYTES),HL
req_d:
		ld	HL,destin16
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get destination address from host
		ld	(DEST_ADR),HL

		;prepare block transfer and search commands like ldi, cpi, cpir, ldir
		ld	HL,(SOURCE_ADR)
		ld	DE,(DEST_ADR)
		ld	BC,(NUMB_OF_BYTES)
		ret




fill_mem:	ld	HL,new_dat
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get fill value from host
		ld	(SCRATCH),A	;save fill value in scratch

		call	req_nd		;request number, destination address
		
		ld	DE,(DEST_ADR)
		ld	BC,(NUMB_OF_BYTES)
l_fi0:
		ld	HL,SCRATCH	;set source pointer to scratch
		ldi			;copy fill value (from scratch) to destination address
		jp	pe,l_fi0	;loop until block filled
		ret


cmp_mem:
		;ld	HL,(SOURCE_ADR)
		;ld	DE,(DEST_ADR)
		;ld	BC,(NUMB_OF_BYTES)
l_cmp0:		ld	A,(DE)		;load data at dest. address into A
		ld	(SCRATCH),A	;place copy of data in scratch
		cpi			;cmp data at source address with data at dest. addr.
		jp	nz,l_cmp_err
		inc	DE		;advance dest. pointer
		jp	pe,l_cmp0	;loop until byte counter bc is 0
		ret
l_cmp_err:	dec	HL		;set source pointer back at address where error occured
		push 	HL		;save current source address
		push	DE		;save current dest. address

		ld	HL,error	;tx "..?"
		call	TX_STR
		ld	HL,at		;tx "at"
		call	TX_STR

		pop	DE		;restore current dest. address
		ld	A,D
		push	DE
		call	APP_ACCU
		pop	DE
		ld	A,E
		call	APP_ACCU
		call	TX_STD_OUT	;tx current dest. address to host
		
		ld	HL,expect	;tx "exp:" to host
		call	TX_STR
		pop	HL		;restore current source address
		ld	A,(HL)
		call	APP_ACCU
		call	TX_STD_OUT	;tx current source address to host
		
		ld	HL,read		;tx "read:"
		call	TX_STR	

		ld	A,(SCRATCH)	;restore from scratch data read at dest. address
		call	APP_ACCU
		call	TX_STD_OUT	;tx corrupted data to host

		ret

		
fl_prog:	;programs data into flash page wise
		ld	HL,NEW_LINE	;transmit new line
		call	TX_STR
		ld	HL,page
		call	TX_STR
		sub	A
		ld	(SCRATCH),A	;clear scratch
		ld	HL,(SOURCE_ADR)
		ld	DE,(DEST_ADR)
		ld	BC,(NUMB_OF_BYTES)
l_prg0:		ld	A,80h		;per page are 80h bytes to load
		call	tx_byte_count	;tx byte count
l_prg2:		dec	A		;first byte of page has number 7Fh, last byte has 0h
		ldi			;copy source_adr to dest_adr, dec bc
		jp	po,l_prg3	;exit if no more bytes are left to load
		jp	nz,l_prg2	;loop until page full
		call	l_pa30ms	;pause 30ms when page full
		jp	l_prg0
l_prg3:		call	l_pa170ms	;pause 170ms
		ret		

tx_byte_count:	push 	AF
		push	DE
		push	HL
		push	BC
		
		ld	A,(SCRATCH)
		;inc	A
		;ld	(SCRATCH),A
		call	APP_ACCU
		call	TX_STD_OUT	;tx page count to host		
		ld	A,(SCRATCH)
		inc	A
		ld	(SCRATCH),A
		

		ld	HL,2xBS		;backspace 2 times to overwrite last output
		call	TX_STR

		pop	BC
		pop	HL
		pop	DE
		pop	AF
		ret





prot_off:	;disables software data protection
		call	l_AA55
		ld	A,080h
		ld	(0D555h),A	;5555h
		call	l_AA55
		ld	A,020h
		ld	(0D555h),A	;5555h
		call	l_pa170ms
		ret

prot_on:	;enables software data protection
		call	l_AA55
		ld	A,0A0h
		ld	(0D555h),A	;5555h
		call	l_pa170ms
		ret

fl_erase:	;erases complete flash
		call	l_AA55
		ld	A,080h
		ld	(0D555h),A	;5555h
		call	l_AA55
		ld	A,010h
		ld	(0D555h),A	;5555h
		call	l_pa170ms
		ret


id_check:	;reads flash id code. must be DA45h for W29C020 type
		;modifies all registers
		
		ld	HL,fl_id
		call	TX_STR
				
		;product id entry
		call	l_AA55
		ld	A,080h
		ld	(0D555h),A	;5555h
		call	l_AA55
		ld	A,060h
		ld	(0D555h),A	;5555h
		call	l_pa170ms
		
		;product id and boot block lockout detection mode
		ld	A,(08000h)	;0h
		call	APP_ACCU
		ld	A,(08001h)	;1h
		call	APP_ACCU

		ld	A,(08002h)	;2h (for lower boot block lockout detection)
		call	APP_ACCU
		call	TX_STD_OUT	;TX id code to host

		;product id exit
		call	l_AA55
		ld	A,0F0h
		ld	(0D555h),A	;5555h
		call	l_pa170ms

		;normal mode reached
		ret



l_pa170ms:	;pause 170ms at 2,5Mhz
		push	AF		;save AF on stack
		push	BC		;save BC on stack
		ld	A,080h
		ld	B,0h
l_133ms:	djnz	l_133ms		;1.33ms at 2,5Mhz
		dec	A
		jp	nz,l_133ms
		pop	BC		;restore BC
		pop	AF		;restore AF
		ret


l_pa30ms:	;pause 30ms at 2,5Mhz
		push	AF		;save AF on stack
		push	BC		;save BC on stack
		ld	A,01Ah
		ld	B,0h
l_a133ms:	djnz	l_a133ms	;1.33ms at 2,5Mhz
		dec	A
		jp	nz,l_a133ms
		pop	BC		;restore BC
		pop	AF		;restore AF
		ret


l_AA55:		;modifies A
		ld	A,0AAh
		ld	(0D555h),A	;5555h
		ld	A,055h
		ld	(0AAAAh),A	;2AAAh
		ret







;***********************************************************************************
;---BSC section begin:



;-------------------------------------------------------------------------------------
RST_BSC:
;resets BSC
;modifies A, HL
	    	ld	HL,0h		;clear vector output buffer length of all SPs
		ld	(V_LEN1),HL
		ld	(V_LEN2),HL
		ld	(V_LEN1_BYTE),HL
		ld	(V_LEN2_BYTE),HL

		ld	A,0Ah
		ld	(STEP_MODE),A	;default of step mode is vector wise (Ah)

		ld	A,4Fh
		out	(PIO_E_C),A	;set PIO E to input mode

		ld	A,0CFh		;set PIO F to bit mode
		out	(PIO_F_C),A
		ld	A,0FFh		;set all I/Os to input mode
		out	(PIO_F_C),A
		ld	A,0F0h		;load output latch:
		;/PWR_ON, /DIO_ON, /TAP_ON, /GND_ON = H
		;/TAP2_EN, /TAP1_EN = L
		;DIO_STRB, TAP_STRB = L
		out	(PIO_F_D),A
		ld	A,0Fh		;set PIO F to output mode
		out	(PIO_F_C),A

		out	(PIO_C_C),A	;set PIO C (SP signals) to output mode
		out	(PIO_D_C),A	;set PIO D (DIO signals) to output mode
		
		ld	A,0AAh		;set PIO C (SP signals):
		;TDOx = H, /TRSTx = L , TMSx = H , TCKx = L
		out	(PIO_C_D),A
		
		ld	A,0FFh		;set PIO D (DIO signals):
		;/DOx_EN = H , DOx = H
		out	(PIO_D_D),A
		call	TAP_DIO_STRB
		
		;init SP1 TDI input treshhold
		call	I2C0_START
		ld	A,58h
		call	I2C0_tx		;send DAC1 dev. sel. code 
		jp	nc,WARM_START	;restart on error
		sub	A
		call	I2C0_tx		;send to DAC1 normal mode command 
		jp	nc,WARM_START	;restart on error
		ld	A,40h		
		call	I2C0_tx		;send DAC1 output value (app. 1,3V)
		jp	nc,WARM_START	;restart on error
		call	I2C0_STOP
		ret




		
		
		
;--------------------------------------------------------------------------------
;resets all SPs 
;clocks 5 times while TMSx is held H
;sets /TRSTx L, then H

tap_rst:	ld	B,05h
l_712:		;ld	A,0AAh
		;TDOx = H, /TRSTx = L , TMSx = H , TCKx = L
		;out	(PIO_C_D),A
		;call	TAP_DIO_STRB
		ld	A,0BBh
		;TDOx = H, /TRSTx = L , TMSx = H , TCKx = H
		out	(PIO_C_D),A
		call	TAP_DIO_STRB
		ld	A,0AAh
		;TDOx = H, /TRSTx = L , TMSx = H , TCKx = L
		out	(PIO_C_D),A
		call	TAP_DIO_STRB
		djnz	l_712		;loop until 5 clocks are done
		ld	A,0EEh
		;TDOx = H, /TRSTx = H , TMSx = H , TCKx = L
		out	(PIO_C_D),A
		call	TAP_DIO_STRB
		ret
;-------------------------------------------------------------------------------







;------------------------------------------------------------------------------
relseqon:
;turns relais for UUT step by step on
;modifies A
		in	A,(PIO_F_D)
		and	11101111b	;/GND_ON = L
		out	(PIO_F_D),A
;		call	wait_2
		and	01111111b	;/PWR_ON = L
		out	(PIO_F_D),A
;		call	wait_2
		and	11011111b	;/TAP_ON = L
		out	(PIO_F_D),A
;		call	wait_2
		and	10111111b	;/DIO_ON = L
		out	(PIO_F_D),A
;		call	wait_2
		ret

relseqoff:
;turns relais for UUT step by step off
;modifies A

		in	A,(PIO_F_D)
		or	01000000b	;/DIO_ON = H
		out	(PIO_F_D),A
;		call	wait_2
		or	00100000b	;/TAP_ON = H
		out	(PIO_F_D),A
;		call	wait_2
		or	10000000b	;/PWR_ON = H
		out	(PIO_F_D),A
;		call	wait_2
		or	00010000b	;/GND_ON = H
		out	(PIO_F_D),A
;		call	wait_2
		ret




;---------------------------------------------------------------------
;requests vector parametes:
;type: 	  01 - drscan / 02 - irscan
;SP_nr:  01,02,03,... / 00 aborts function
;length:  max 2^16 bits
;sh_out:  number to scan out
req_vec_par:
		ld	HL,type
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get vector type from host
		ld	(V_TYPE),A

l_717:		ld	HL,tap_nr
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get tap nr from host
		cp	0h		;if tap nr=0 return
		ret	z
		cp	1h
		jp	z,l_716		;if tap nr=1
		cp	2h
		jp	z,l_715		;if tap nr=2
		jp	l_717

l_716:		call	req_len		;get tap 1 vector length from host
		ld	(V_LEN1),HL
		call	req_out_val	;get tap 1 output vector from host
		ld	(V_LEN1_BYTE),BC;save number of bytes (needed for transfer of
					;input buffer V_IN1 to host)
		ld	DE,V_OUT1	;destination is output buffer of tap 1
		call	mv_vector
		jp	l_717

l_715:		call	req_len		;get tap 2 vector length from host
		ld	(V_LEN2),HL
		call	req_out_val	;get tap 2 output vector from host
		ld	(V_LEN2_BYTE),BC;save number of bytes (needed for transfer of
					;input buffer V_IN2 to host)
		ld	DE,V_OUT2	;destination is output buffer of tap 2
		call	mv_vector
		jp	l_717


req_out_val:
;requests value to be shifted out into UUT from host
		ld	HL,sh_out
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get vector shift out value from host
					;(gets stored in long number storage)
		ld	BC,(IN_LEN)	;IN_LEN holds number of chars in input buffer
		call	div_by_2	;so IN_LEN must be divided by 2 to obtain number of bytes
					;present in long number storage (NUMBER)
					;BC holds number of bytes now
		ret

req_len:
;requests vector length from host
		ld	HL,length
		call	TX_STR
;		call	TX_STR_TERM
		call	req_number	;get tap vector length from host
		ret


mv_vector:
;moves content of long number storage into tap vector output buffer
;starts with lowbyte of vector at beginning of buffer
;modifies HL, BC, DE
l_7121:		ld	HL,NUMBER	;HL holds start pos of long number storage
		add	HL,BC
		dec	HL		;HL points to lowbyte of vector
		LDI			;move vector to tap 1 output buffer
		jp	pe,l_7121	;until all bytes are moved
		ret




;------------------------------------------------------------------------------
;executes vector present in V_OUT1
;value in V_LEN1 determines length of vector (unit is bit), max length is 2^16

exec_vec:	ld	HL,0
		ld	(TCK_NR),HL	;clear tck counter (used in single tck step mode)

		ld	IY,V_IN1
		ld	IX,TDI1_BB
		sub	A
		ld	(TDI1_BB),A	;clear tdi1 bit buffer
		ld	(TDI1_BC),A	;clear tdi1 bit counter

		;in case of Test-Logic-Reset
		in	A,(PIO_C_D)
		and	11111101b	;M1 L
		call	tap_out
		;-------------
		call	TCK1_CYCLE	;enter RT/IDLE
					;RT/IDLE stable
		or	00000010b	;M1 H
		call	tap_out
		call	TCK1_CYCLE	;enter Select-DR-Scan
					;Select-DR-Scan stable
		ld	B,A		;backup PIO C output pattern in B
		ld	A,(V_TYPE)
		cp	1		;test if type is 1
		jp	z,cap_xr	;if yes, next state is capture-dr
		jp	sel_ir		;if no, next state is select-ir

cap_xr:		ld	A,B		;restore PIO C output pattern from B
		and	11111101b	;M1 L
		call	tap_out
		call	TCK1_CYCLE	;enter Capture-XR
					;Capture-XR stable
sh_xr:		call	TCK1_CYCLE	;enter Shift-XR
					;Shift-XR stable

		ld	HL,V_OUT1	;HL points to beginning of vector in output buffer tap1
		ld	DE,(V_LEN1)	;DE holds length of vector

l_697:		ld	C,(HL)		;C holds byte to scan out
		ld	B,8h		;8 bits are to scan out
l_695:		push	AF		;backup SP status on stack
		ld	A,D		;test if high byte of length is 0
		cp	0
		jp	nz,l_693	;if no, proceed at l_693
		ld	A,E		;else test if low byte of length is 0
		cp	0
		jp	z,l_696		;if yes leave current state EXIT1-XR
		cp	1		;test if low byte of length is 1
		jp	nz,l_693	;if no, po